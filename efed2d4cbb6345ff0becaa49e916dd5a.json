{"posts": [{"title": "Git Command", "date": "2022-06-24T18:51:00-00.00", "path": "/Blog/archives/git/", "text": "\n\u8bb0\u5f55\u5e38\u7528\u7684git command$ git clone # Clone a repo to local\n$ git clone -b AIRISCPiM  - -single-branch &lt;url&gt; # Clone a specific branch\n$ git branch # Show current branch\n$ git checkout # Switch to another branch\n$ git add . # adds all changes in the working directory to the staging area\n$ git add *.c # Add only C files\n$ git add fortz.c diff.py # Add specific files\n$ git restore --stage &lt;file&gt; # Unstage: Discard uncommitted local changes in the local branch. (Want to redo after git add)\n$ git commit -m &quot;First Commit&quot; # Commit the changes\n$ git reset --soft AIRISCPiM~11 # Remove git commit but keep the change, AIRISCPiM is the branch name, ~11 is how many commits to remove\n$ git reset &lt;file&gt; # Untrack a specific file\n$ git push -u origin AIRISCPiM # Push to a branch(AIRISCPiM) from local repo(origin)\n$ git push # When you are on the right branch just do git push\n$ git pull # Fetch and download content from a remote repo and update local repo\n$ git status # Displays the state of the working directory and the staging area\n\n", "categories": [{"name": "cheetsheet", "slug": "cheetsheet", "permalink": "/Blog/category/cheetsheet/"}], "tags": [{"name": "git", "slug": "git", "permalink": "/Blog/tag/git/"}]}, {"title": "Linux and Vim cheatsheet", "date": "2022-06-11T23:27:00-00.00", "path": "/Blog/archives/linux&vim/", "text": "\u8bb0\u5f55\u5e38\u7528\u7684Linux\u6307\u4ee4\u548cVim\u6307\u4ee4Linux\npwd     # Find out the path of the current working directory\ncd -    # Move to your previous directory\nls -R   # List all the files in sub-directories as well\nls -a   # Show the hidden files\nls -al  # List add detailed information\ncp -r /from /dest\nmv -r /from /dest\nrm -rf # \u5220\u5e93\u8dd1\u8def(\u65e0\u6cd5\u64a4\u56de)\ngrep -r \u201cfdfdsaf\u201d lib/*/*prx   # Find patterns in followed location\ndiff f1.v f2.v # Find differences between two files\njobs    # List your background processes\nkill %n # Kill a process by ID\ngrep &quot;&quot; / # Find patterns in a directory\n\nVim\n:s/foo/bar/       # Substitute first work     \n:s/foo/bar/g      # Substitute first line\n:%s/foo/bar/g     # Substitute all\n:%s/foo/bar/gc    # Substitute all but ask for confirmation\n:split            # Split the screen\n:vsplit           # (ctrl+w followed by arrow key to switch)\n:e /location      # Open a file  \n:e $MYVIMRC       # Edit the configurable file\n\n", "categories": [{"name": "Cheatsheet", "slug": "Cheatsheet", "permalink": "/Blog/category/Cheatsheet/"}], "tags": [{"name": "Linux", "slug": "Linux", "permalink": "/Blog/tag/Linux/"}, {"name": "Vim", "slug": "Vim", "permalink": "/Blog/tag/Vim/"}]}, {"title": "Coding Interview Questions", "date": "2022-06-11T22:33:00-00.00", "path": "/Blog/archives/interview_question/", "text": "\u8bb0\u5f55\u5e38\u89c1\u7684\u624b\u6495\u4ee3\u7801\u95ee\u9898=&gt;Github Repo\u5947\u6570\u5206\u9891\nmodule f3 #(\n    parameter N = 3\n)(\n    input clk,\n    input rst_n,\n    output clk2\n);\nreg clk2_r;\nreg [31:0] count;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n||count==N-1)\n        count &lt;= 0;\n    else\n        count &lt;= count + 1;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        clk2_r &lt;= 0;\n    else if(count==0||count==1)\n        clk2_r &lt;= ~clk2_r;\n\nassign clk2 = clk2_r;\n\nendmodule\n\n\u5947\u6570\u5206\u9891\uff0850%\u5360\u7a7a\u6bd4\uff09\nmodule fn_50p#(\n    parameter N = 5\n)(\n    input clk,\n    input rst_n,\n    output clk2\n);\n\nreg posedge_clk2;\nreg negedge_clk2;\nreg [31:0] posedge_count;\nreg [31:0] negedge_count;\n\n// Posedge counter\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n || posedge_count==N-1)\n        posedge_count &lt;= 0;\n    else\n        posedge_count &lt;= posedge_count + 1;\n\n// Negedge counter\nalways @(negedge clk or negedge rst_n)\n    if (!rst_n || negedge_count==N-1)\n        negedge_count &lt;= 0;\n    else\n        negedge_count &lt;= negedge_count + 1;\n\n// Posedge clock\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        posedge_clk2 &lt;= 0;\n    else if (posedge_count==(N-1)/2||posedge_count==N-1)\n        posedge_clk2 &lt;= ~posedge_clk2;\n\n// Negedge clock\nalways @(negedge clk or negedge rst_n)\n    if (!rst_n)\n        negedge_clk2 &lt;= 0;\n    else if (negedge_count==(N-1)/2||negedge_count==N-1)\n        negedge_clk2 &lt;= ~negedge_clk2;\n\nassign clk2 = posedge_clk2 | negedge_clk2;\n\nendmodule\n\n\u5076\u6570\u5206\u9891 (\u65b9\u6cd5\u4e00)\nmodule even_divide #(\n    parameter N = 8\n)(\n    input clk,\n    input rst_n,\n    output clk2\n);\nreg clk2_r;\nreg [31:0] count;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n||count==N/2-1)\n        count &lt;= 0;\n    else\n        count &lt;= count + 1;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        clk2_r &lt;= 0;\n    else if (count==N/2-1)\n        clk2_r &lt;= ~clk2_r;\n\nassign clk2 = clk2_r;\n\nendmodule\n\n\u5076\u6570\u5206\u9891\uff08\u65b9\u6cd5\u4e8c\uff09\n// Register method\nmodule even_divide (\n    input clk,\n    input rst_n,\n    output clk2,\n    output clk4,\n    output clk8\n);\n\nreg clk2_r;\nreg clk4_r;\nreg clk8_r;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        clk2_r &lt;= 0;\n    else\n        clk2_r &lt;= ~clk2_r;\n\nalways @(posedge clk2 or negedge rst_n)\n    if (!rst_n)\n        clk4_r &lt;= 0;\n    else\n        clk4_r &lt;= ~clk4_r;\n\nalways @(posedge clk4 or negedge rst_n)\n    if (!rst_n)\n        clk8_r &lt;= 0;\n    else \n        clk8_r &lt;= ~clk8_r;\n\nassign {clk2, clk4, clk8} = {clk2_r, clk4_r, clk8_r};\n\nendmodule\n\n\u5c0f\u6570\u5206\u9891(8.6\u5206\u9891)\nmodule fraction_divide #(\n    parameter M_N = 86,\n    parameter c86 = 32,\n    parameter div_e = 8,\n    parameter div_o = 9\n)(\n    input clk,\n    input rst_n,\n    output reg clk2\n);\nreg [31:0] count;\nreg [31:0] count_even;\nreg [31:0] count_odd;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n || count==M_N-1)\n        count &lt;= 0;\n    else\n        count &lt;= count + 1;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n) begin\n        count_even  &lt;= 0;\n        count_odd &lt;= 0;\n    end\n    else if (count&lt;=c86-1) begin\n        count_odd &lt;= 0;\n        if (count_even==div_e-1)\n            count_even &lt;= 0;\n        else\n            count_even &lt;= count_even + 1;\n    end\n    else begin\n        count_odd &lt;= 0;\n        if (count_odd==div_o-1) \n            count_odd &lt;= 0;\n        else\n            count_odd &lt;= count_odd + 1;\n    end\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        clk2 &lt;= 0;\n    else if (count&lt;=c86 &amp;&amp; count_even==0 || count_even==div_e/2)\n        clk2 &lt;= ~clk2;\n    else if (count&gt;c86 &amp;&amp; count_odd==0 || count_odd==(div_o-1)/2)\n        clk2 &lt;= ~clk2;\n\nendmodule\n\n\u534a\u5206\u9891 (50%\u5360\u7a7a\u6bd4)\nmodule half_divide #(\n    parameter N = 3 // Meaning 3.5 frequency divider\n)(\n    input clk,\n    input rst_n,\n    output clk2\n);\nreg [31:0] p_cnt;\nreg [31:0] n_cnt;\n\nwire p_clk;\nwire n_clk;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n || p_cnt==2*N)\n        p_cnt &lt;= 0;\n    else\n        p_cnt &lt;= p_cnt + 1;\n\nalways @(negedge clk or negedge rst_n)\n    if (!rst_n || n_cnt==2*N)\n        n_cnt &lt;= 0;\n    else \n        n_cnt &lt;= n_cnt + 1;\n\nassign p_clk = p_cnt == 0;\nassign n_clk = n_cnt == N;\nassign clk2 = p_clk | n_clk;\n\nendmodule\n\n\u6a21\u4e09\u68c0\u6d4b\u5668\uff08\u901a\u8fc7\u79fb\u4f4d\u8bbe\u8ba1moore fsm\uff09\nmodule mod3_check(\n    input clk,\n    input rst_n,\n    input data,\n    output test\n);\n\nparameter IDLE=3&#39;b000,s0=3&#39;b001,s1=3&#39;b010,s2=3&#39;b100;\nreg [3:0] state, next_state;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        state &lt;= IDLE;\n    else\n        state &lt;= next_state;\n\nalways @(*)\n    case (state)\n        IDLE: next_state = data?s1:s0;\n        s0:next_state = data?s1:s0;\n        s1: next_state = data?s0:s2;\n        s2: next_state = data?s2:s1;\n        default: next_state = IDLE;\n    endcase\n\nassign test = state==s0;\nendmodule\n\n\u5e8f\u5217\u68c0\u6d4b\u5668\uff081001\uff09\nMealy FSM approach\nmodule sequence_check_mealy(\n    input clk,\n    input rst_n,\n    input sequence,\n    output test\n);\n\nparameter IDLE = 3&#39;b000, s1 = 3&#39;b001, s2 = 3&#39;b010, s3 = 3&#39;b100;\nreg [2:0] state, next_state;\nreg test_reg, next_test;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n) begin\n        state &lt;= IDLE;\n        test_reg &lt;= 0;\n    end\n    else begin\n        state &lt;= next_state;\n        test_reg &lt;= next_test;\n    end\n\nalways @(*)\n    case (state)\n        IDLE: begin\n            next_state = sequence? s1 : IDLE;\n            next_test = 0;\n        end\n        s1: begin\n            next_state = sequence? s1 : s2;\n            next_test = 0;\n        end\n        s2: begin\n            next_state = sequence? s1 : s3;\n            next_test = 0;\n        end\n        s3: begin\n            next_state = sequence? s1 : IDLE;\n            next_test = sequence==1;\n        end\n        default: begin\n            next_state = IDLE;\n            next_test = 0;\n        end\n    endcase\n    assign test = test_reg;\nendmodule\n\nMoore FSM approach\nmodule sequence_check_moore(\n    input clk,\n    input rst_n,\n    input sequence,\n    output test\n);\n\nparameter IDLE=4&#39;b0000,s1=4&#39;b0001,s2=4&#39;b0010,s3=4&#39;b0100,s4=4&#39;b1000;\n\nreg [3:0] state, next_state;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        state &lt;= 0;\n    else\n        state &lt;= next_state;\n\nalways @(*)\n    case (state)\n        IDLE: next_state = sequence?s1:IDLE;\n        s1: next_state = sequence?s1:s2;\n        s2: next_state = sequence?s1:s3;\n        s3: next_state = sequence?s4:IDLE;\n        s4: next_state = sequence?s1:s2;\n    endcase\n\nassign test = state==s4;\n\nendmodule\n\nTestbench with configurable 10-bit input sequence.\n`timescale 1ns/1ps\nmodule sequence_check_moore_tb();\nreg clk;\nreg rst_n;\nreg sequence;\nwire test;\n\nparameter test_seq = 10&#39;b1100100110;\n\nalways #5 clk &lt;= ~clk;\n\ntask SEND_SEQ;\n    input [9:0] i_seq;\n    integer ii;\n    begin\n        sequence = 0;\n        #10;\n        for (ii=9; ii&gt;=0;ii=ii-1) begin\n            sequence = i_seq[ii];\n            #10;\n        end\n    end\nendtask\n\nsequence_check_moore dut(.clk(clk),.rst_n(rst_n),.sequence(sequence),.test(test));\n\ninitial begin\n$dumpfile(&quot;sequence_check_moore_tb.vcd&quot;); \n$dumpvars(0, sequence_check_moore_tb);\nsequence = 0;\nclk = 0;\nrst_n = 1;\n#5\nrst_n = 0;\n#10\nrst_n = 1;\n#10\nSEND_SEQ(test_seq);\n$stop;\n\nend\nendmodule\n\nVending Machine\nmodule vending_machine(\n    input clk,\n    input rst_n,\n    input [1:0] coin,\n    output drink,\n    output change\n);\n\nparameter IDLE = 4&#39;b0000, s1 = 4&#39;b0001, s2 = 4&#39;b0010, s3 = 4&#39;b0100, s4 = 4&#39;b1000;\n\nreg [3:0] state, next_state;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        state &lt;= IDLE;\n    else\n        state &lt;= next_state;\n\nalways @(*)\n    case (state)\n        IDLE: next_state = coin[1] ? s2 : (coin[0] ? s1 : IDLE);\n        s1: next_state = coin[1] ? s3 : (coin[0] ? s2 : s1);\n        s2: next_state = coin[1] ? s4 : (coin[0] ? s3 : s2);\n        s3: next_state = IDLE;\n        s4: next_state = IDLE;\n        default: next_state = IDLE;\n    endcase\n\nassign drink = state==s3||state==s4;\nassign change = state==s4;\n\nendmodule\n\nAsynchronous reset, synchronous release\n\u907f\u514d\u5f02\u6b65\u590d\u4f4d\u5728\u91ca\u653e\u7684\u65f6\u5019\u4e0d\u6ee1\u8db3setup/hold time\u800c\u4ea7\u751f\u4e9a\u7a33\u6001\nmodule sync_async_rst(\n    input clk,\n    input rst_n,\n    output rst_out\n);\nreg rst_temp;\nreg rst_out_reg;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n) begin\n        rst_temp &lt;= 0;\n        rst_out_reg &lt;= 0;\n    end\n    else begin\n        rst_temp &lt;= rst_n;\n        rst_out_reg &lt;= rst_temp;\n    end\n\nassign rst_out = rst_out_reg;\n\nendmodule\n\nBinary to gray converter\nDesign:\nmodule gray2bin #(\n    parameter WIDTH = 4\n)(\n    input [WIDTH-1:0] G,\n    output [WIDTH-1:0] bin\n);\n\nreg [WIDTH-1:0] bin_reg;\ninteger i;\n\nalways @(*) begin\n    bin_reg[WIDTH-1] = G[WIDTH-1];\n    for (i=WIDTH-2; i&gt;=0; i=i-1) begin\n        bin_reg[i] = bin_reg[i+1]^G[i];\n    end\nend\n\nassign bin = bin_reg;\n\nendmodule\n\nTestbench:\nmodule bin2gray_tb();\nparameter WIDTH = 4;\n\nreg [WIDTH-1:0] bin;\nwire [WIDTH-1:0] G;\n\ninteger i;\n\nbin2gray #(WIDTH(WIDTH)) dut(.bin(bin),.G(G));\n\ninitial begin\n    $dumpfile(&quot;bin2gray_tb.vcd&quot;); \n    $dumpvars(0, bin2gray_tb);\n    bin = 0;\n    #10\n    for (i=0; i&lt;2**WIDTH; i=i+1) begin\n        bin = bin + 1;\n        #10;\n    end\n    $stop;\nend\n\nendmodule\n\nGray to binary converter\nDesign\nmodule gray2bin #(\n    parameter WIDTH = 4\n)(\n    input [WIDTH-1:0] G,\n    output [WIDTH-1:0] bin\n);\n\nreg [WIDTH-1:0] bin_reg;\ninteger i;\n\nalways @(*) begin\n    bin_reg[WIDTH-1] = G[WIDTH-1];\n    for (i=WIDTH-2; i&gt;=0; i=i-1) begin\n        bin_reg[i] = bin_reg[i+1]^G[i];\n    end\nend\n\nassign bin = bin_reg;\n\nendmodule\n\nTestbench:\nmodule gray2bin_tb();\nparameter WIDTH = 4;\n\nreg [WIDTH-1:0] G;\nwire [WIDTH-1:0] bin;\n\ninteger i;\n\ngray2bin #(.WIDTH(WIDTH)) dut (.bin(bin),.G(G));\n\ninitial begin\n    $dumpfile(&quot;gray2bin_tb.vcd&quot;); \n    $dumpvars(0, gray2bin_tb);\n    G = 0;\n    #10\n    for (i=0; i&lt;2**WIDTH; i=i+1) begin\n        G = G + 1;\n        #10;\n    end\n    $stop;\nend\n\nendmodule\n\nEdge detector\nmodule edge_detector(\n    input clk,\n    input signal,\n    output pe,\n    output ne,\n    output either_edge\n);\nreg signal_reg;\n\nalways @(posedge clk)\n    signal_reg &lt;= signal;\n\nassign pe = signal &amp; ~signal_reg;\nassign ne = ~signal &amp; signal_reg;\nassign either_edge = pe | ne;\n\nendmodule\n\nTypical problems in HDLBits\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).\nreset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.\nThe following timing diagram shows the rollover behaviour from 11:59:59 AM to 12:00:00 PM and the synchronous reset and enable behaviour.\nmodule top_module(\n    input clk,\n    input reset,\n    input ena,\n    output pm,\n    output [7:0] hh,\n    output [7:0] mm,\n    output [7:0] ss); \n    wire enable[4:1];\n\n    cnt #(.START(0), .END(9)) ss0(clk, reset, ena, ss[3:0]);\n    cnt #(.START(0), .END(5)) ss1(clk, reset, enable[1], ss[7:4]);\n    cnt #(.START(0), .END(9)) mm0(clk, reset, enable[2], mm[3:0]);\n    cnt #(.START(0), .END(5)) mm1(clk, reset, enable[3], mm[7:4]);\n    cnt_hour h(clk, reset, enable[4], hh[7:0], pm);\n\n    assign enable[1] = ena &amp;&amp; ss[3:0] == 4&#39;h9;\n    assign enable[2] = enable[1] &amp;&amp; ss[7:4] == 4&#39;h5;\n    assign enable[3] = enable[2] &amp;&amp; mm[3:0] == 4&#39;h9;\n    assign enable[4] = enable[3] &amp;&amp; mm[7:4] == 4&#39;h5;\n\nendmodule\n\nmodule cnt (\n    input clk,\n    input reset,\n    input ena,\n    output reg [3:0] q\n);\nparameter START = 0, END = 9;\nalways @(posedge clk)\n    if (reset)\n        q &lt;= START;\n    else if(~ena) q &lt;= q;\n    else q &lt;= q &lt; END? q + 1 : START;\nendmodule\n\nmodule cnt_hour (\n    input clk,\n    input reset,\n    input ena,\n    output reg [7:0] q,\n    output reg pm\n);\nalways @(posedge clk)\n    if (reset) q &lt;= 8&#39;h12;\n    else if(~ena) q &lt;= q;\n    else case (q)\n            8&#39;h12: q &lt;= 8&#39;h01;\n            8&#39;h09: q &lt;= 8&#39;h10;\n            default: q[3:0] &lt;= q[3:0] + 1;\n        endcase\nalways @(posedge clk)\n    if (reset) pm &lt;= 0;\n    else if(ena &amp;&amp; q == 8&#39;h11) pm &lt;= ~pm;\nendmodule\n\nOdd parity\nmodule odd_sel(\n  input [31:0] bus,\n  input        sel, // sel = 1 check if odd, sel = 0 check if even\n  output check\n);\nwire check_tmp;\nassign check_tmp = ^bus;\nassign check = sel ? check_tmp : ~check_tmp;\nendmodule\n\n", "categories": [{"name": "IC Interview", "slug": "IC Interview", "permalink": "/Blog/category/IC Interview/"}], "tags": [{"name": "Verilog", "slug": "Verilog", "permalink": "/Blog/tag/Verilog/"}, {"name": "GitHub", "slug": "GitHub", "permalink": "/Blog/tag/GitHub/"}]}, {"title": "Verilog Cheat Sheet", "date": "2022-04-03T23:52:00-00.00", "path": "/Blog/archives/verilog_cheat_sheet/", "text": "\u8bb0\u5f55\u4e00\u4e0b\u5237\u9898\u8fc7\u7a0b\u4e2dVerilog\u603b\u5fd8\uff0c\u603b\u641e\u6df7\u7684\u8bed\u6cd5\uff01If Statement\nWhen there are more than one commands, add begin ... end syntax for that branch.\nif ()\nelse if()\nelse\n\nCase\nAgain add begin ... end syntax when there are more than one commands.\ncase (A)\n3&#39;b001:\n3&#39;b010:\n3&#39;b100:\ndefault:\nendcase\n\nLoop\nInside always block...\ninteger i;\nalways @(posedge clk) begin\n  for (i=1; i&lt;100; i=i+1) begin\n  end\nend\n\nOutside always block...\ngenvar i;\ngenerate\n  for (i=0; i&lt;255; i=i+1) begin loop_name\n  end\nendgenerate\n\nDuplication\nSome examples...\nassign a = {51{1&#39;b1}};\nassign b = {width{A}};\nassign {b, a[2:1], c} = {};\nassign out = {{24{in[7]}}, in}; // Sign bit extension\nassign out = {in[0], in[1], in[2], in[3]}; // Reverse\n\nOnehot\nmodule onehot(input [255:0] r1, input [7:0] addr, output out);\n  assign out = r[addr];\nendmodule\n\nMasking\nassign Q = r1[addr*4+3 -: 4];\n\nDefine a Register File\nmodule regfile(\n    input clk,\n    input we3,\n    input [4:0] ra1, ra2, wa3,\n    input [63:0] wd3,\n    output [63:0] rd1, rd2\n  );\n  reg [63:0] rf [31:0];\n\n  always @(posedge clk)\n    if (we3) rf[wa3] &lt;= wd3;\n\n  assign rd1 = (ra1!=0)? rf[ra1] : 0;\n  assign rd2 = (ra2!=0)? rf[ra2] : 0;\n\n  endmodule\n\n", "categories": [{"name": "Cheatsheet", "slug": "Cheatsheet", "permalink": "/Blog/category/Cheatsheet/"}], "tags": [{"name": "Verilog", "slug": "Verilog", "permalink": "/Blog/tag/Verilog/"}, {"name": "GitHub", "slug": "GitHub", "permalink": "/Blog/tag/GitHub/"}]}, {"title": "\u6211\u7684\u7b2c\u4e00\u7bc7\u6587\u7ae0", "date": "2022-04-02T16:34:00-00.00", "path": "/Blog/archives/my-first-awesome-post/", "text": "\u8fd9\u662f\u6211\u7684\u7b2c\u4e00\u7bc7\u6587\u7ae0\u3002\u6587\u7ae0\u4f7f\u7528 GitHub \u7ba1\u7406\uff0c\u5e76\u901a\u8fc7 GitHub Actions \u81ea\u52a8\u6784\u5efa\u4e0e\u53d1\u5e03\uff01\n", "categories": [{"name": "\u9ed8\u8ba4\u5206\u7c7b", "slug": "\u9ed8\u8ba4\u5206\u7c7b", "permalink": "/Blog/category/\u9ed8\u8ba4\u5206\u7c7b/"}], "tags": [{"name": "\u535a\u5ba2", "slug": "\u535a\u5ba2", "permalink": "/Blog/tag/\u535a\u5ba2/"}, {"name": "GitHub", "slug": "GitHub", "permalink": "/Blog/tag/GitHub/"}]}], "pages": [{"title": "\u5173\u4e8e", "date": "2017-06-28T17:26:00-00.00", "path": "/Blog/about/", "text": "\u8fd9\u91cc\u662f\u6211\u7684\u4e2a\u4eba\u535a\u5ba2\uff0c\u901a\u8fc7 GitHub \u7ba1\u7406\u4e0e\u6784\u5efa\u3002\nContact\nEmail: hi#imalan.cn (replace # with @)\nTelegram\uff1aAlanDecode\n", "categories": [], "tags": []}]}