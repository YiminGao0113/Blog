{"posts": [{"title": "Linux and vim cheatsheet", "date": "2022-06-11T23:27:00-00.00", "path": "/Blog/archives/linux&vim/", "text": "\u8bb0\u5f55\u5e38\u7528\u7684linux\u6307\u4ee4\u548cvim\u6307\u4ee4Linux\npwd     # Find out the path of the current working directory\ncd -    # Move to your previous directory\nls -R   # List all the files in sub-directories as well\nls -a   # Show the hidden files\nls -al  # List add detailed information\ncp -r /(from) /(dest) \nmv -r /(from) /(dest) \nrm -rf # \u5220\u5e93\u8dd1\u8def\ngrep -r \u201cfdfdsaf\u201d lib/*/*prx   # Find patterns in followed location\ndiff f1.v f2.v # Find differences between two files\njobs    # List your background processes\nkill %n # Kill a process by ID\n\nVim\nSubstitute first work     :s/foo/bar/\nSubstitute first line     :s/foo/bar/g\nSubstitute all        :%s/foo/bar/g\nSubstitute all but ask for confirmation       :%s/foo/bar/gc\nSplit     :split  :vsplit (ctrl+w followed by arrow key to switch) :e /location(Open a file)\nFind patterns in a directory      grep \u201cfdfdsaf\u201d lib//prx\nEdit the configurable file  :e $MYVIMRC\n", "categories": [{"name": "Cheatsheet", "slug": "Cheatsheet", "permalink": "/Blog/category/Cheatsheet/"}], "tags": [{"name": "Linux", "slug": "Linux", "permalink": "/Blog/tag/Linux/"}, {"name": "Vim", "slug": "Vim", "permalink": "/Blog/tag/Vim/"}]}, {"title": "Coding Interview Questions", "date": "2022-06-11T22:33:00-00.00", "path": "/Blog/archives/interview_question/", "text": "\u8bb0\u5f55\u5e38\u89c1\u7684\u624b\u6495\u4ee3\u7801\u95ee\u9898=&gt;Github Repo\u5947\u6570\u5206\u9891\nmodule f3 #(\n    parameter N = 3\n)(\n    input clk,\n    input rst_n,\n    output clk2\n);\nreg clk2_r;\nreg [31:0] count;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n||count==N-1)\n        count &lt;= 0;\n    else\n        count &lt;= count + 1;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        clk2_r &lt;= 0;\n    else if(count==0||count==1)\n        clk2_r &lt;= ~clk2_r;\n\nassign clk2 = clk2_r;\n\nendmodule\n\n\u5947\u6570\u5206\u9891\uff0850%\u5360\u7a7a\u6bd4\uff09\nmodule fn_50p#(\n    parameter N = 5\n)(\n    input clk,\n    input rst_n,\n    output clk2\n);\n\nreg posedge_clk2;\nreg negedge_clk2;\nreg [31:0] posedge_count;\nreg [31:0] negedge_count;\n\n// Posedge counter\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n || posedge_count==N-1)\n        posedge_count &lt;= 0;\n    else\n        posedge_count &lt;= posedge_count + 1;\n\n// Negedge counter\nalways @(negedge clk or negedge rst_n)\n    if (!rst_n || negedge_count==N-1)\n        negedge_count &lt;= 0;\n    else\n        negedge_count &lt;= negedge_count + 1;\n\n// Posedge clock\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        posedge_clk2 &lt;= 0;\n    else if (posedge_count==(N-1)/2||posedge_count==N-1)\n        posedge_clk2 &lt;= ~posedge_clk2;\n\n// Negedge clock\nalways @(negedge clk or negedge rst_n)\n    if (!rst_n)\n        negedge_clk2 &lt;= 0;\n    else if (negedge_count==(N-1)/2||negedge_count==N-1)\n        negedge_clk2 &lt;= ~negedge_clk2;\n\nassign clk2 = posedge_clk2 | negedge_clk2;\n\nendmodule\n\n\u5076\u6570\u5206\u9891 (\u65b9\u6cd5\u4e00)\nmodule even_divide #(\n    parameter N = 8\n)(\n    input clk,\n    input rst_n,\n    output clk2\n);\nreg clk2_r;\nreg [31:0] count;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n||count==N/2-1)\n        count &lt;= 0;\n    else\n        count &lt;= count + 1;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        clk2_r &lt;= 0;\n    else if (count==N/2-1)\n        clk2_r &lt;= ~clk2_r;\n\nassign clk2 = clk2_r;\n\nendmodule\n\n\u5076\u6570\u5206\u9891\uff08\u65b9\u6cd5\u4e8c\uff09\n// Register method\nmodule even_divide (\n    input clk,\n    input rst_n,\n    output clk2,\n    output clk4,\n    output clk8\n);\n\nreg clk2_r;\nreg clk4_r;\nreg clk8_r;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        clk2_r &lt;= 0;\n    else\n        clk2_r &lt;= ~clk2_r;\n\nalways @(posedge clk2 or negedge rst_n)\n    if (!rst_n)\n        clk4_r &lt;= 0;\n    else\n        clk4_r &lt;= ~clk4_r;\n\nalways @(posedge clk4 or negedge rst_n)\n    if (!rst_n)\n        clk8_r &lt;= 0;\n    else \n        clk8_r &lt;= ~clk8_r;\n\nassign {clk2, clk4, clk8} = {clk2_r, clk4_r, clk8_r};\n\nendmodule\n\n\u5c0f\u6570\u5206\u9891(8.6\u5206\u9891)\nmodule fraction_divide #(\n    parameter M_N = 86,\n    parameter c86 = 32,\n    parameter div_e = 8,\n    parameter div_o = 9\n)(\n    input clk,\n    input rst_n,\n    output reg clk2\n);\nreg [31:0] count;\nreg [31:0] count_even;\nreg [31:0] count_odd;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n || count==M_N-1)\n        count &lt;= 0;\n    else\n        count &lt;= count + 1;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n) begin\n        count_even  &lt;= 0;\n        count_odd &lt;= 0;\n    end\n    else if (count&lt;=c86-1) begin\n        count_odd &lt;= 0;\n        if (count_even==div_e-1)\n            count_even &lt;= 0;\n        else\n            count_even &lt;= count_even + 1;\n    end\n    else begin\n        count_odd &lt;= 0;\n        if (count_odd==div_o-1) \n            count_odd &lt;= 0;\n        else\n            count_odd &lt;= count_odd + 1;\n    end\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        clk2 &lt;= 0;\n    else if (count&lt;=c86 &amp;&amp; count_even==0 || count_even==div_e/2)\n        clk2 &lt;= ~clk2;\n    else if (count&gt;c86 &amp;&amp; count_odd==0 || count_odd==(div_o-1)/2)\n        clk2 &lt;= ~clk2;\n\nendmodule\n\n\u534a\u5206\u9891 (50%\u5360\u7a7a\u6bd4)\nmodule half_divide #(\n    parameter N = 3 // Meaning 3.5 frequency divider\n)(\n    input clk,\n    input rst_n,\n    output clk2\n);\nreg [31:0] p_cnt;\nreg [31:0] n_cnt;\n\nwire p_clk;\nwire n_clk;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n || p_cnt==2*N)\n        p_cnt &lt;= 0;\n    else\n        p_cnt &lt;= p_cnt + 1;\n\nalways @(negedge clk or negedge rst_n)\n    if (!rst_n || n_cnt==2*N)\n        n_cnt &lt;= 0;\n    else \n        n_cnt &lt;= n_cnt + 1;\n\nassign p_clk = p_cnt == 0;\nassign n_clk = n_cnt == N;\nassign clk2 = p_clk | n_clk;\n\nendmodule\n\n\u6a21\u4e09\u68c0\u6d4b\u5668\uff08\u901a\u8fc7\u79fb\u4f4d\u8bbe\u8ba1moore fsm\uff09\nmodule mod3_check(\n    input clk,\n    input rst_n,\n    input data,\n    output test\n);\n\nparameter IDLE=3&#39;b000,s0=3&#39;b001,s1=3&#39;b010,s2=3&#39;b100;\nreg [3:0] state, next_state;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        state &lt;= IDLE;\n    else\n        state &lt;= next_state;\n\nalways @(*)\n    case (state)\n        IDLE: next_state = data?s1:s0;\n        s0:next_state = data?s1:s0;\n        s1: next_state = data?s0:s2;\n        s2: next_state = data?s2:s1;\n        default: next_state = IDLE;\n    endcase\n\nassign test = state==s0;\nendmodule\n\n\u5e8f\u5217\u68c0\u6d4b\u5668\uff081001\uff09\nMealy FSM approach\nmodule sequence_check_mealy(\n    input clk,\n    input rst_n,\n    input sequence,\n    output test\n);\n\nparameter IDLE = 3&#39;b000, s1 = 3&#39;b001, s2 = 3&#39;b010, s3 = 3&#39;b100;\nreg [2:0] state, next_state;\nreg test_reg, next_test;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n) begin\n        state &lt;= IDLE;\n        test_reg &lt;= 0;\n    end\n    else begin\n        state &lt;= next_state;\n        test_reg &lt;= next_test;\n    end\n\nalways @(*)\n    case (state)\n        IDLE: begin\n            next_state = sequence? s1 : IDLE;\n            next_test = 0;\n        end\n        s1: begin\n            next_state = sequence? s1 : s2;\n            next_test = 0;\n        end\n        s2: begin\n            next_state = sequence? s1 : s3;\n            next_test = 0;\n        end\n        s3: begin\n            next_state = sequence? s1 : IDLE;\n            next_test = sequence==1;\n        end\n        default: begin\n            next_state = IDLE;\n            next_test = 0;\n        end\n    endcase\n    assign test = test_reg;\nendmodule\n\nMoore FSM approach\nmodule sequence_check_moore(\n    input clk,\n    input rst_n,\n    input sequence,\n    output test\n);\n\nparameter IDLE=4&#39;b0000,s1=4&#39;b0001,s2=4&#39;b0010,s3=4&#39;b0100,s4=4&#39;b1000;\n\nreg [3:0] state, next_state;\n\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n)\n        state &lt;= 0;\n    else\n        state &lt;= next_state;\n\nalways @(*)\n    case (state)\n        IDLE: next_state = sequence?s1:IDLE;\n        s1: next_state = sequence?s1:s2;\n        s2: next_state = sequence?s1:s3;\n        s3: next_state = sequence?s4:IDLE;\n        s4: next_state = sequence?s1:s2;\n    endcase\n\nassign test = state==s4;\n\nendmodule\n\nTestbench with configurable 10-bit input sequence.\n`timescale 1ns/1ps\nmodule sequence_check_moore_tb();\nreg clk;\nreg rst_n;\nreg sequence;\nwire test;\n\nparameter test_seq = 10&#39;b1100100110;\n\nalways #5 clk &lt;= ~clk;\n\ntask SEND_SEQ;\n    input [9:0] i_seq;\n    integer ii;\n    begin\n        sequence = 0;\n        #10;\n        for (ii=9; ii&gt;=0;ii=ii-1) begin\n            sequence = i_seq[ii];\n            #10;\n        end\n    end\nendtask\n\nsequence_check_moore dut(.clk(clk),.rst_n(rst_n),.sequence(sequence),.test(test));\n\ninitial begin\n$dumpfile(&quot;sequence_check_moore_tb.vcd&quot;); \n$dumpvars(0, sequence_check_moore_tb);\nsequence = 0;\nclk = 0;\nrst_n = 1;\n#5\nrst_n = 0;\n#10\nrst_n = 1;\n#10\nSEND_SEQ(test_seq);\n$stop;\n\nend\nendmodule\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nTypical problems in HDLBits\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).\nreset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.\nThe following timing diagram shows the rollover behaviour from 11:59:59 AM to 12:00:00 PM and the synchronous reset and enable behaviour.\nmodule top_module(\n    input clk,\n    input reset,\n    input ena,\n    output pm,\n    output [7:0] hh,\n    output [7:0] mm,\n    output [7:0] ss); \n    wire enable[4:1];\n\n    cnt #(.START(0), .END(9)) ss0(clk, reset, ena, ss[3:0]);\n    cnt #(.START(0), .END(5)) ss1(clk, reset, enable[1], ss[7:4]);\n    cnt #(.START(0), .END(9)) mm0(clk, reset, enable[2], mm[3:0]);\n    cnt #(.START(0), .END(5)) mm1(clk, reset, enable[3], mm[7:4]);\n    cnt_hour h(clk, reset, enable[4], hh[7:0], pm);\n\n    assign enable[1] = ena &amp;&amp; ss[3:0] == 4&#39;h9;\n    assign enable[2] = enable[1] &amp;&amp; ss[7:4] == 4&#39;h5;\n    assign enable[3] = enable[2] &amp;&amp; mm[3:0] == 4&#39;h9;\n    assign enable[4] = enable[3] &amp;&amp; mm[7:4] == 4&#39;h5;\n\nendmodule\n\nmodule cnt (\n    input clk,\n    input reset,\n    input ena,\n    output reg [3:0] q\n);\nparameter START = 0, END = 9;\nalways @(posedge clk)\n    if (reset)\n        q &lt;= START;\n    else if(~ena) q &lt;= q;\n    else q &lt;= q &lt; END? q + 1 : START;\nendmodule\n\nmodule cnt_hour (\n    input clk,\n    input reset,\n    input ena,\n    output reg [7:0] q,\n    output reg pm\n);\nalways @(posedge clk)\n    if (reset) q &lt;= 8&#39;h12;\n    else if(~ena) q &lt;= q;\n    else case (q)\n            8&#39;h12: q &lt;= 8&#39;h01;\n            8&#39;h09: q &lt;= 8&#39;h10;\n            default: q[3:0] &lt;= q[3:0] + 1;\n        endcase\nalways @(posedge clk)\n    if (reset) pm &lt;= 0;\n    else if(ena &amp;&amp; q == 8&#39;h11) pm &lt;= ~pm;\nendmodule\n\nOdd parity\nmodule odd_sel(\n  input [31:0] bus,\n  input        sel, // sel = 1 check if odd, sel = 0 check if even\n  output check\n);\nwire check_tmp;\nassign check_tmp = ^bus;\nassign check = sel ? check_tmp : ~check_tmp;\nendmodule\n\n=======\n&gt; 4021b5b97f3bbd98e5c65f293d89207c5f3fb61c\n\n\n\n\n\n\n\n", "categories": [{"name": "IC Interview", "slug": "IC Interview", "permalink": "/Blog/category/IC Interview/"}], "tags": [{"name": "Verilog", "slug": "Verilog", "permalink": "/Blog/tag/Verilog/"}, {"name": "GitHub", "slug": "GitHub", "permalink": "/Blog/tag/GitHub/"}]}, {"title": "Verilog Cheat Sheet", "date": "2022-04-03T23:52:00-00.00", "path": "/Blog/archives/verilog_cheat_sheet/", "text": "\u8bb0\u5f55\u4e00\u4e0b\u5237\u9898\u8fc7\u7a0b\u4e2dVerilog\u603b\u5fd8\uff0c\u603b\u641e\u6df7\u7684\u8bed\u6cd5\uff01If Statement\nWhen there are more than one commands, add begin ... end syntax for that branch.\nif ()\nelse if()\nelse\n\nCase\nAgain add begin ... end syntax when there are more than one commands.\ncase (A)\n3&#39;b001:\n3&#39;b010:\n3&#39;b100:\ndefault:\nendcase\n\nLoop\nInside always block...\ninteger i;\nalways @(posedge clk) begin\n  for (i=1; i&lt;100; i=i+1) begin\n  end\nend\n\nOutside always block...\ngenvar i;\ngenerate\n  for (i=0; i&lt;255; i=i+1) begin loop_name\n  end\nendgenerate\n\nDuplication\nSome examples...\nassign a = {51{1&#39;b1}};\nassign b = {width{A}};\nassign {b, a[2:1], c} = {};\nassign out = {{24{in[7]}}, in}; // Sign bit extension\nassign out = {in[0], in[1], in[2], in[3]}; // Reverse\n\nOnehot\nmodule onehot(input [255:0] r1, input [7:0] addr, output out);\n  assign out = r[addr];\nendmodule\n\nMasking\nassign Q = r1[addr*4+3 -: 4];\n\nDefine a Register File\nmodule regfile(\n    input clk,\n    input we3,\n    input [4:0] ra1, ra2, wa3,\n    input [63:0] wd3,\n    output [63:0] rd1, rd2\n  );\n  reg [63:0] rf [31:0];\n\n  always @(posedge clk)\n    if (we3) rf[wa3] &lt;= wd3;\n\n  assign rd1 = (ra1!=0)? rf[ra1] : 0;\n  assign rd2 = (ra2!=0)? rf[ra2] : 0;\n\n  endmodule\n\n", "categories": [{"name": "Cheatsheet", "slug": "Cheatsheet", "permalink": "/Blog/category/Cheatsheet/"}], "tags": [{"name": "Verilog", "slug": "Verilog", "permalink": "/Blog/tag/Verilog/"}, {"name": "GitHub", "slug": "GitHub", "permalink": "/Blog/tag/GitHub/"}]}, {"title": "\u6211\u7684\u7b2c\u4e00\u7bc7\u6587\u7ae0", "date": "2022-04-02T16:34:00-00.00", "path": "/Blog/archives/my-first-awesome-post/", "text": "\u8fd9\u662f\u6211\u7684\u7b2c\u4e00\u7bc7\u6587\u7ae0\u3002\u6587\u7ae0\u4f7f\u7528 GitHub \u7ba1\u7406\uff0c\u5e76\u901a\u8fc7 GitHub Actions \u81ea\u52a8\u6784\u5efa\u4e0e\u53d1\u5e03\uff01\n", "categories": [{"name": "\u9ed8\u8ba4\u5206\u7c7b", "slug": "\u9ed8\u8ba4\u5206\u7c7b", "permalink": "/Blog/category/\u9ed8\u8ba4\u5206\u7c7b/"}], "tags": [{"name": "\u535a\u5ba2", "slug": "\u535a\u5ba2", "permalink": "/Blog/tag/\u535a\u5ba2/"}, {"name": "GitHub", "slug": "GitHub", "permalink": "/Blog/tag/GitHub/"}]}], "pages": [{"title": "\u5173\u4e8e", "date": "2017-06-28T17:26:00-00.00", "path": "/Blog/about/", "text": "\u8fd9\u91cc\u662f\u6211\u7684\u4e2a\u4eba\u535a\u5ba2\uff0c\u901a\u8fc7 GitHub \u7ba1\u7406\u4e0e\u6784\u5efa\u3002\nContact\nEmail: hi#imalan.cn (replace # with @)\nTelegram\uff1aAlanDecode\n", "categories": [], "tags": []}]}